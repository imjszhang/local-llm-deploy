<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>GLM-5 监控</title>
    <style>
        :root { --bg: #0f0f12; --card: #1a1a1f; --text: #e4e4e7; --muted: #71717a; --accent: #22c55e; --warn: #eab308; }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: ui-sans-serif, system-ui, sans-serif; background: var(--bg); color: var(--text); min-height: 100vh; padding: 1.5rem; }
        h1 { font-size: 1.5rem; margin-bottom: 1rem; }
        .card { background: var(--card); border-radius: 0.5rem; padding: 1rem; margin-bottom: 1rem; }
        .card h2 { font-size: 0.875rem; color: var(--muted); margin-bottom: 0.5rem; text-transform: uppercase; }
        .metric { display: flex; justify-content: space-between; padding: 0.25rem 0; font-family: ui-monospace, monospace; }
        .metric span:last-child { color: var(--accent); }
        .status { display: inline-block; width: 0.5rem; height: 0.5rem; border-radius: 50%; margin-right: 0.5rem; }
        .status.ok { background: var(--accent); }
        .status.err { background: #ef4444; }
        .api-row { display: flex; gap: 0.5rem; align-items: center; margin-bottom: 1rem; }
        .api-row input { flex: 1; padding: 0.5rem; border-radius: 0.25rem; border: 1px solid #27272a; background: var(--card); color: var(--text); }
        .api-row button { padding: 0.5rem 1rem; border-radius: 0.25rem; border: none; background: var(--accent); color: #000; cursor: pointer; font-weight: 500; }
        .api-row button:hover { opacity: 0.9; }
        .nav { margin-bottom: 1rem; }
        .nav a { color: var(--muted); text-decoration: none; margin-right: 1rem; }
        .nav a:hover { color: var(--text); }
        .slot { padding: 0.5rem; background: #27272a; border-radius: 0.25rem; margin-bottom: 0.5rem; font-size: 0.875rem; }
        .slot.busy { border-left: 3px solid var(--accent); animation: pulse 2s ease-in-out infinite; }
        @keyframes pulse { 0%, 100% { border-left-color: var(--accent); } 50% { border-left-color: #16a34a; } }
        .slot-header { display: flex; justify-content: space-between; align-items: center; }
        .slot-progress { color: var(--muted); font-size: 0.75rem; margin-top: 0.25rem; font-family: ui-monospace, monospace; }
        .slot-hint { color: var(--warn); }
        .slot-generated { margin-top: 0.5rem; padding: 0.5rem; background: #1a1a1f; border-radius: 0.25rem; font-family: ui-monospace, monospace; font-size: 0.8rem; line-height: 1.4; max-height: 300px; overflow-y: auto; white-space: pre-wrap; word-break: break-word; color: var(--text); border: 1px solid #333; }
        .slot-thinking { margin-top: 0.5rem; padding: 0.5rem; background: #1e1e24; border-radius: 0.25rem; font-family: ui-monospace, monospace; font-size: 0.8rem; line-height: 1.4; max-height: 200px; overflow-y: auto; white-space: pre-wrap; word-break: break-word; color: var(--muted); border-left: 3px solid #6366f1; }
        .slot-thinking-title { font-size: 0.7rem; color: #6366f1; margin-bottom: 0.25rem; text-transform: uppercase; }
        .slot-muted { color: var(--muted); }
        .error { color: #ef4444; font-size: 0.875rem; }
        .refresh { color: var(--muted); font-size: 0.75rem; margin-top: 0.5rem; }
    </style>
</head>
<body>
    <h1>GLM-5 监控</h1>

    <div class="card">
        <h2>配置</h2>
        <div class="api-row">
            <input type="text" id="apiBase" placeholder="默认 /api 使用代理（自动读取 .api-key）">
            <button onclick="localStorage.setItem('glm5_api_base', document.getElementById('apiBase').value.trim() || '/api'); fetchAll()">保存</button>
            <button onclick="localStorage.removeItem('glm5_api_base'); location.reload()" style="background:var(--muted)">清除缓存</button>
        </div>
        <p class="refresh">默认 /api 经本服务代理，自动认证。推理时 /metrics、/slots 会阻塞，轮询已降频（12s）以避免服务卡死，超时后会提示「推理中」。</p>
    </div>

    <div class="card">
        <h2>健康状态</h2>
        <div class="metric">
            <span><span class="status" id="healthDot"></span>服务</span>
            <span id="healthText">-</span>
        </div>
    </div>

    <div class="card">
        <h2>推理指标</h2>
        <div id="metrics"></div>
    </div>

    <div class="card">
        <h2>槽位状态</h2>
        <div id="slots"></div>
    </div>

    <p class="refresh" id="lastUpdate">-</p>

    <script>
        function escapeHtml(str) {
            return str.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
        }
        // 从生成文本中解析 <think>...</think> 思考内容
        function parseThinkingAndContent(gen) {
            const thinkMatch = gen.match(/<think>([\s\S]*?)(?:<\/think>|$)/);
            const thinking = thinkMatch ? thinkMatch[1].trim() : '';
            const afterThink = thinkMatch ? gen.slice(gen.indexOf(thinkMatch[0]) + thinkMatch[0].length) : gen;
            const content = afterThink.replace(/^[\s\n]+/, '').trim();
            return { thinking, content };
        }

        let hasProcessing = false;
        let pollTimer = null;
        const POLL_FAST = 12000;   // 推理时 12s 轮询（/metrics、/slots 会阻塞主循环，过于频繁会导致服务卡死）
        const POLL_IDLE = 10000;  // 空闲时 10s 刷新

        function headers() {
            return { 'Accept': 'application/json, text/plain' };
        }

        function parseMetrics(text) {
            const m = {};
            for (const line of text.split('\n')) {
                if (line.startsWith('llamacpp:')) {
                    const match = line.match(/^(llamacpp:[^\s{]+)\s*(?:\{[^}]*\})?\s+([\d.e+-]+)/);
                    if (match) m[match[1]] = parseFloat(match[2]);
                }
            }
            return m;
        }

        const LABELS = {
            'llamacpp:prompt_tokens_total': 'Prompt Tokens',
            'llamacpp:tokens_predicted_total': '生成 Tokens',
            'llamacpp:prompt_tokens_seconds': 'Prompt 吞吐 (tokens/s)',
            'llamacpp:predicted_tokens_seconds': '生成吞吐 (tokens/s)',
            'llamacpp:prompt_seconds_total': 'Prompt 总耗时 (s)',
            'llamacpp:tokens_predicted_seconds_total': '生成总耗时 (s)',
            'llamacpp:n_decode_total': '解码总次数',
            'llamacpp:requests_processing': '处理中请求',
            'llamacpp:requests_deferred': '排队请求',
            'llamacpp:n_busy_slots_per_decode': '忙碌槽位/解码',
            'llamacpp:n_tokens_max': '最大上下文',
        };

        function apiUrl(path) {
            let base = localStorage.getItem('glm5_api_base') || '/api';
            if (base.includes('8001') || base.includes(':8001')) {
                base = '/api';
                localStorage.setItem('glm5_api_base', base);
            }
            if (base.startsWith('http')) return base.replace(/\/$/, '') + path;
            const origin = window.location.origin || 'http://localhost:8888';
            return origin + (base.startsWith('/') ? base : '/' + base) + path;
        }

        // 推理时 llama-server 的 /metrics /slots 会阻塞，短超时快速释放线程，代理层 8s 超时
        const MONITOR_TIMEOUT_MS = 10000;  // 10s，略大于代理超时
        const BLOCKED_HINT = '推理中，监控接口被阻塞，请稍后刷新';
        function fetchWithTimeout(url, opts, ms = MONITOR_TIMEOUT_MS) {
            const ctrl = new AbortController();
            const timer = setTimeout(() => ctrl.abort(), ms);
            return fetch(url, { ...opts, signal: ctrl.signal }).finally(() => clearTimeout(timer));
        }

        function errMsg(e) {
            if (!e) return BLOCKED_HINT;
            if (e.name === 'AbortError') return BLOCKED_HINT;
            const msg = (e.message || '').toLowerCase();
            if (msg.includes('abort') || msg.includes('aborted')) return BLOCKED_HINT;
            return e.message || BLOCKED_HINT;
        }

        let firstLoad = true;
        async function fetchAll() {
            const scrollY = window.scrollY;
            const base = localStorage.getItem('glm5_api_base') || '/api';
            if (base.includes('8001') || base.includes(':8001')) {
                localStorage.setItem('glm5_api_base', '/api');
            }
            document.getElementById('apiBase').value = base.includes('8001') ? '/api' : base;

            // 局部刷新：不整体清空，仅首屏显示加载
            if (firstLoad) {
                document.getElementById('metrics').innerHTML = '<div class="metric slot-muted">加载中...</div>';
                document.getElementById('slots').innerHTML = '<div class="metric slot-muted">加载中...</div>';
            }

            // 独立请求：单个端点失败不影响其他，只更新成功的部分
            const [healthResult, metricsResult, slotsResult] = await Promise.allSettled([
                fetchWithTimeout(apiUrl('/health'), { headers: headers() }),
                fetchWithTimeout(apiUrl('/metrics'), { headers: headers() }),
                fetchWithTimeout(apiUrl('/slots'), { headers: headers() })
            ]);

            // 健康状态
            if (healthResult.status === 'fulfilled') {
                const healthRes = healthResult.value;
                document.getElementById('healthDot').className = 'status ' + (healthRes.ok ? 'ok' : 'err');
                document.getElementById('healthText').textContent = healthRes.ok ? '正常' : `错误 ${healthRes.status}`;
            } else {
                document.getElementById('healthDot').className = 'status err';
                document.getElementById('healthText').textContent = errMsg(healthResult.reason);
            }

            // 推理指标：仅在有结果时更新，失败则保留原内容
            if (metricsResult.status === 'fulfilled') {
                const metricsRes = metricsResult.value;
                if (metricsRes.ok) {
                    const text = await metricsRes.text();
                    const m = parseMetrics(text);
                    document.getElementById('metrics').innerHTML = Object.entries(LABELS)
                        .filter(([k]) => k in m)
                        .map(([k, label]) => `<div class="metric"><span>${label}</span><span>${typeof m[k] === 'number' && m[k] % 1 ? m[k].toFixed(2) : m[k]}</span></div>`)
                        .join('') || '<div class="metric"><span>无数据</span></div>';
                } else {
                    const msg = metricsRes.status === 504 ? BLOCKED_HINT : (metricsRes.status === 401 ? '需认证' : `获取失败 (${metricsRes.status})`);
                    document.getElementById('metrics').innerHTML = `<div class="error">${msg}</div>`;
                }
            }
            // metrics 失败时不覆盖，保留原内容

            // 槽位状态：仅在有结果时更新
            if (slotsResult.status === 'fulfilled') {
                const slotsRes = slotsResult.value;
                if (slotsRes.ok) {
                    try {
                        const slots = await slotsRes.json();
                        if (Array.isArray(slots)) {
                            hasProcessing = slots.some(s => s.is_processing);
                            document.getElementById('slots').innerHTML = slots.map(s => {
                                if (!s.is_processing) {
                                    return `<div class="slot"><span class="slot-header">#${s.id} 空闲</span></div>`;
                                }
                                const nt = Array.isArray(s.next_token) ? s.next_token[0] : (s.next_token || {});
                                const decoded = nt.n_decoded ?? '?';
                                const remain = nt.n_remain ?? '?';
                                const maxP = s.params?.n_predict;
                                let progress = `已生成 ${decoded} tokens`;
                                if (remain !== '?' && remain >= 0) progress += ` / 剩余 ${remain}`;
                                if (maxP !== undefined) progress += ` (max=${maxP})`;
                                const gen = (s.generated ?? s.generated_text ?? s.output ?? s.content ?? '') || '';
                                const reasoning = (s.reasoning ?? s.reasoning_content ?? '') || '';
                                let genHtml;
                                if (gen || reasoning) {
                                    const { thinking, content } = parseThinkingAndContent(gen);
                                    const showThinking = reasoning || thinking;
                                    const showContent = content || (!showThinking && gen);
                                    const parts = [];
                                    if (showThinking) {
                                        parts.push(`<div class="slot-thinking"><div class="slot-thinking-title">思考</div>${escapeHtml(reasoning || thinking)}</div>`);
                                    }
                                    if (showContent) {
                                        parts.push(`<div class="slot-generated">${escapeHtml(content || gen)}</div>`);
                                    } else if (showThinking) {
                                        parts.push(`<div class="slot-generated slot-muted">回复生成中...</div>`);
                                    }
                                    genHtml = parts.join('');
                                } else if (decoded !== '?' && decoded > 0) {
                                    genHtml = `<div class="slot-progress slot-hint">需启用 slots_debug 才能查看生成内容。请用 deploy.sh 重启服务（已设置 LLAMA_SERVER_SLOTS_DEBUG=1）</div>`;
                                } else {
                                    genHtml = `<div class="slot-progress">等待生成...</div>`;
                                }
                                return `<div class="slot busy"><div class="slot-header"><span>#${s.id} 处理中</span></div><div class="slot-progress">${progress}</div>${genHtml}</div>`;
                            }).join('');
                        } else {
                            document.getElementById('slots').innerHTML = '<div class="metric"><span>无槽位数据</span></div>';
                        }
                    } catch (e) {
                        document.getElementById('slots').innerHTML = `<div class="error">解析失败: ${e.message}</div>`;
                    }
                } else {
                    const msg = slotsRes.status === 504 ? BLOCKED_HINT : `获取失败 (${slotsRes.status})`;
                    document.getElementById('slots').innerHTML = `<div class="error">${msg}</div>`;
                }
            }
            // slots 失败时不覆盖，保留原内容

            document.getElementById('lastUpdate').textContent = `上次更新: ${new Date().toLocaleTimeString('zh-CN')}`;

            // 自动滚动生成内容区和思考区到底部
            document.querySelectorAll('.slot-generated, .slot-thinking').forEach(el => { el.scrollTop = el.scrollHeight; });

            requestAnimationFrame(() => window.scrollTo(0, scrollY));
            firstLoad = false;

            // 有推理时 2s 更新槽位，空闲时 10s 刷新
            schedulePoll();
        }

        function schedulePoll() {
            if (pollTimer) clearTimeout(pollTimer);
            if (document.hidden) return;
            pollTimer = setTimeout(fetchAll, hasProcessing ? POLL_FAST : POLL_IDLE);
        }

        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                if (pollTimer) { clearTimeout(pollTimer); pollTimer = null; }
            } else {
                fetchAll();
            }
        });

        fetchAll();
    </script>
</body>
</html>
