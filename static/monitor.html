<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>LLM 监控</title>
    <style>
        :root { --bg: #0f0f12; --card: #1a1a1f; --text: #e4e4e7; --muted: #71717a; --accent: #22c55e; --warn: #eab308; }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: ui-sans-serif, system-ui, sans-serif; background: var(--bg); color: var(--text); min-height: 100vh; padding: 1.5rem; }
        h1 { font-size: 1.5rem; margin-bottom: 1rem; }
        .card { background: var(--card); border-radius: 0.5rem; padding: 1rem; margin-bottom: 1rem; }
        .card h2 { font-size: 0.875rem; color: var(--muted); margin-bottom: 0.5rem; text-transform: uppercase; }
        .metric { display: flex; justify-content: space-between; padding: 0.25rem 0; font-family: ui-monospace, monospace; }
        .metric span:last-child { color: var(--accent); }
        .status { display: inline-block; width: 0.5rem; height: 0.5rem; border-radius: 50%; margin-right: 0.5rem; }
        .status.ok { background: var(--accent); }
        .status.err { background: #ef4444; }
        .config-row { display: flex; gap: 0.5rem; align-items: center; margin-bottom: 0.75rem; flex-wrap: wrap; }
        .config-row select, .config-row input { padding: 0.5rem; border-radius: 0.25rem; border: 1px solid #27272a; background: var(--card); color: var(--text); }
        .config-row select { min-width: 160px; }
        .config-row input { flex: 1; min-width: 200px; }
        .config-row button { padding: 0.5rem 1rem; border-radius: 0.25rem; border: none; background: var(--accent); color: #000; cursor: pointer; font-weight: 500; white-space: nowrap; }
        .config-row button:hover { opacity: 0.9; }
        .config-row button.secondary { background: var(--muted); }
        .nav { margin-bottom: 1rem; }
        .nav a { color: var(--muted); text-decoration: none; margin-right: 1rem; }
        .nav a:hover { color: var(--text); }
        .slot { padding: 0.5rem; background: #27272a; border-radius: 0.25rem; margin-bottom: 0.5rem; font-size: 0.875rem; }
        .slot.busy { border-left: 3px solid var(--accent); animation: pulse 2s ease-in-out infinite; }
        @keyframes pulse { 0%, 100% { border-left-color: var(--accent); } 50% { border-left-color: #16a34a; } }
        .slot-header { display: flex; justify-content: space-between; align-items: center; }
        .slot-progress { color: var(--muted); font-size: 0.75rem; margin-top: 0.25rem; font-family: ui-monospace, monospace; }
        .slot-hint { color: var(--warn); }
        .slot-generated { margin-top: 0.5rem; padding: 0.5rem; background: #1a1a1f; border-radius: 0.25rem; font-family: ui-monospace, monospace; font-size: 0.8rem; line-height: 1.4; max-height: 300px; overflow-y: auto; white-space: pre-wrap; word-break: break-word; color: var(--text); border: 1px solid #333; }
        .slot-thinking { margin-top: 0.5rem; padding: 0.5rem; background: #1e1e24; border-radius: 0.25rem; font-family: ui-monospace, monospace; font-size: 0.8rem; line-height: 1.4; max-height: 200px; overflow-y: auto; white-space: pre-wrap; word-break: break-word; color: var(--muted); border-left: 3px solid #6366f1; }
        .slot-thinking-title { font-size: 0.7rem; color: #6366f1; margin-bottom: 0.25rem; text-transform: uppercase; }
        .slot-muted { color: var(--muted); }
        .error { color: #ef4444; font-size: 0.875rem; }
        .refresh { color: var(--muted); font-size: 0.75rem; margin-top: 0.5rem; }
        .model-badge { display: inline-block; padding: 0.15rem 0.5rem; border-radius: 0.25rem; background: #27272a; color: var(--accent); font-size: 0.75rem; font-family: ui-monospace, monospace; margin-left: 0.5rem; }
    </style>
</head>
<body>
    <h1>LLM 监控 <span class="model-badge" id="currentModelBadge">-</span></h1>

    <div class="card">
        <h2>配置</h2>
        <div class="config-row">
            <select id="modelSelect">
                <option value="">加载中...</option>
            </select>
            <input type="text" id="apiBase" placeholder="API 地址（留空使用代理）" style="display:none">
            <button onclick="saveConfig()">刷新</button>
            <button class="secondary" onclick="resetConfig()">重置</button>
        </div>
        <p class="refresh">选择模型后自动通过代理路由。推理时 /metrics、/slots 会阻塞，轮询已降频以避免服务卡死。</p>
    </div>

    <div class="card">
        <h2>健康状态</h2>
        <div class="metric">
            <span><span class="status" id="healthDot"></span>服务</span>
            <span id="healthText">-</span>
        </div>
    </div>

    <div class="card">
        <h2>推理指标</h2>
        <div id="metrics"></div>
    </div>

    <div class="card">
        <h2>槽位状态</h2>
        <div id="slots"></div>
    </div>

    <p class="refresh" id="lastUpdate">-</p>

    <script>
        function escapeHtml(str) {
            return str.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
        }
        function parseThinkingAndContent(gen) {
            const thinkMatch = gen.match(/<think>([\s\S]*?)(?:<\/think>|$)/);
            const thinking = thinkMatch ? thinkMatch[1].trim() : '';
            const afterThink = thinkMatch ? gen.slice(gen.indexOf(thinkMatch[0]) + thinkMatch[0].length) : gen;
            const content = afterThink.replace(/^[\s\n]+/, '').trim();
            return { thinking, content };
        }

        let hasProcessing = false;
        let pollTimer = null;
        let currentModel = localStorage.getItem('llm_current_model') || '';
        let modelsLoaded = false;
        const POLL_FAST = 12000;
        const POLL_IDLE = 10000;

        function headers() {
            return { 'Accept': 'application/json, text/plain' };
        }

        // 加载运行中的模型列表
        async function loadModels() {
            const select = document.getElementById('modelSelect');
            try {
                const origin = window.location.origin || 'http://localhost:8888';
                const resp = await fetch(origin + '/api/models', { headers: headers() });
                if (resp.ok) {
                    const models = await resp.json();
                    select.innerHTML = '';
                    if (models.length === 0) {
                        select.innerHTML = '<option value="">无运行中的模型</option>';
                        currentModel = '';
                    } else {
                        models.forEach(m => {
                            const opt = document.createElement('option');
                            opt.value = m.name;
                            opt.textContent = `${m.model || m.name} (:${m.port})`;
                            opt.title = `路由: /api/${m.name}/*  请求体 model: ${m.model || m.name}`;
                            select.appendChild(opt);
                        });
                        if (currentModel && models.some(m => m.name === currentModel)) {
                            select.value = currentModel;
                        } else {
                            currentModel = models[0].name;
                            select.value = currentModel;
                        }
                    }
                    modelsLoaded = true;
                }
            } catch (e) {
                select.innerHTML = '<option value="">连接失败</option>';
            }
            updateModelBadge();
        }

        function updateModelBadge() {
            document.getElementById('currentModelBadge').textContent = currentModel || '-';
        }

        function apiUrl(path) {
            const origin = window.location.origin || 'http://localhost:8888';
            if (currentModel) {
                return origin + '/api/' + currentModel + path;
            }
            return origin + '/api' + path;
        }

        function saveConfig() {
            const select = document.getElementById('modelSelect');
            currentModel = select.value;
            localStorage.setItem('llm_current_model', currentModel);
            updateModelBadge();
            fetchAll();
        }

        function resetConfig() {
            localStorage.removeItem('llm_current_model');
            currentModel = '';
            loadModels().then(() => fetchAll());
        }

        document.getElementById('modelSelect').addEventListener('change', function() {
            currentModel = this.value;
            localStorage.setItem('llm_current_model', currentModel);
            updateModelBadge();
            fetchAll();
        });

        function parseMetrics(text) {
            const m = {};
            for (const line of text.split('\n')) {
                if (line.startsWith('llamacpp:')) {
                    const match = line.match(/^(llamacpp:[^\s{]+)\s*(?:\{[^}]*\})?\s+([\d.e+-]+)/);
                    if (match) m[match[1]] = parseFloat(match[2]);
                }
            }
            return m;
        }

        const LABELS = {
            'llamacpp:prompt_tokens_total': 'Prompt Tokens',
            'llamacpp:tokens_predicted_total': '生成 Tokens',
            'llamacpp:prompt_tokens_seconds': 'Prompt 吞吐 (tokens/s)',
            'llamacpp:predicted_tokens_seconds': '生成吞吐 (tokens/s)',
            'llamacpp:prompt_seconds_total': 'Prompt 总耗时 (s)',
            'llamacpp:tokens_predicted_seconds_total': '生成总耗时 (s)',
            'llamacpp:n_decode_total': '解码总次数',
            'llamacpp:requests_processing': '处理中请求',
            'llamacpp:requests_deferred': '排队请求',
            'llamacpp:n_busy_slots_per_decode': '忙碌槽位/解码',
            'llamacpp:n_tokens_max': '最大上下文',
        };

        const MONITOR_TIMEOUT_MS = 10000;
        const BLOCKED_HINT = '推理中，监控接口被阻塞，请稍后刷新';
        function fetchWithTimeout(url, opts, ms = MONITOR_TIMEOUT_MS) {
            const ctrl = new AbortController();
            const timer = setTimeout(() => ctrl.abort(), ms);
            return fetch(url, { ...opts, signal: ctrl.signal }).finally(() => clearTimeout(timer));
        }

        function errMsg(e) {
            if (!e) return BLOCKED_HINT;
            if (e.name === 'AbortError') return BLOCKED_HINT;
            const msg = (e.message || '').toLowerCase();
            if (msg.includes('abort') || msg.includes('aborted')) return BLOCKED_HINT;
            return e.message || BLOCKED_HINT;
        }

        let firstLoad = true;
        async function fetchAll() {
            if (!modelsLoaded) {
                await loadModels();
            }

            const scrollY = window.scrollY;

            if (firstLoad) {
                document.getElementById('metrics').innerHTML = '<div class="metric slot-muted">加载中...</div>';
                document.getElementById('slots').innerHTML = '<div class="metric slot-muted">加载中...</div>';
            }

            const [healthResult, metricsResult, slotsResult] = await Promise.allSettled([
                fetchWithTimeout(apiUrl('/health'), { headers: headers() }),
                fetchWithTimeout(apiUrl('/metrics'), { headers: headers() }),
                fetchWithTimeout(apiUrl('/slots'), { headers: headers() })
            ]);

            if (healthResult.status === 'fulfilled') {
                const healthRes = healthResult.value;
                document.getElementById('healthDot').className = 'status ' + (healthRes.ok ? 'ok' : 'err');
                document.getElementById('healthText').textContent = healthRes.ok ? '正常' : `错误 ${healthRes.status}`;
            } else {
                document.getElementById('healthDot').className = 'status err';
                document.getElementById('healthText').textContent = errMsg(healthResult.reason);
            }

            if (metricsResult.status === 'fulfilled') {
                const metricsRes = metricsResult.value;
                if (metricsRes.ok) {
                    const text = await metricsRes.text();
                    const m = parseMetrics(text);
                    document.getElementById('metrics').innerHTML = Object.entries(LABELS)
                        .filter(([k]) => k in m)
                        .map(([k, label]) => `<div class="metric"><span>${label}</span><span>${typeof m[k] === 'number' && m[k] % 1 ? m[k].toFixed(2) : m[k]}</span></div>`)
                        .join('') || '<div class="metric"><span>无数据</span></div>';
                } else {
                    const msg = metricsRes.status === 504 ? BLOCKED_HINT : (metricsRes.status === 401 ? '需认证' : `获取失败 (${metricsRes.status})`);
                    document.getElementById('metrics').innerHTML = `<div class="error">${msg}</div>`;
                }
            }

            if (slotsResult.status === 'fulfilled') {
                const slotsRes = slotsResult.value;
                if (slotsRes.ok) {
                    try {
                        const slots = await slotsRes.json();
                        if (Array.isArray(slots)) {
                            hasProcessing = slots.some(s => s.is_processing);
                            document.getElementById('slots').innerHTML = slots.map(s => {
                                if (!s.is_processing) {
                                    return `<div class="slot"><span class="slot-header">#${s.id} 空闲</span></div>`;
                                }
                                const nt = Array.isArray(s.next_token) ? s.next_token[0] : (s.next_token || {});
                                const decoded = nt.n_decoded ?? '?';
                                const remain = nt.n_remain ?? '?';
                                const maxP = s.params?.n_predict;
                                let progress = `已生成 ${decoded} tokens`;
                                if (remain !== '?' && remain >= 0) progress += ` / 剩余 ${remain}`;
                                if (maxP !== undefined) progress += ` (max=${maxP})`;
                                const gen = (s.generated ?? s.generated_text ?? s.output ?? s.content ?? '') || '';
                                const reasoning = (s.reasoning ?? s.reasoning_content ?? '') || '';
                                let genHtml;
                                if (gen || reasoning) {
                                    const { thinking, content } = parseThinkingAndContent(gen);
                                    const showThinking = reasoning || thinking;
                                    const showContent = content || (!showThinking && gen);
                                    const parts = [];
                                    if (showThinking) {
                                        parts.push(`<div class="slot-thinking"><div class="slot-thinking-title">思考</div>${escapeHtml(reasoning || thinking)}</div>`);
                                    }
                                    if (showContent) {
                                        parts.push(`<div class="slot-generated">${escapeHtml(content || gen)}</div>`);
                                    } else if (showThinking) {
                                        parts.push(`<div class="slot-generated slot-muted">回复生成中...</div>`);
                                    }
                                    genHtml = parts.join('');
                                } else if (decoded !== '?' && decoded > 0) {
                                    genHtml = `<div class="slot-progress slot-hint">需启用 slots_debug 才能查看生成内容。请用 deploy.sh 重启服务（已设置 LLAMA_SERVER_SLOTS_DEBUG=1）</div>`;
                                } else {
                                    genHtml = `<div class="slot-progress">等待生成...</div>`;
                                }
                                return `<div class="slot busy"><div class="slot-header"><span>#${s.id} 处理中</span></div><div class="slot-progress">${progress}</div>${genHtml}</div>`;
                            }).join('');
                        } else {
                            document.getElementById('slots').innerHTML = '<div class="metric"><span>无槽位数据</span></div>';
                        }
                    } catch (e) {
                        document.getElementById('slots').innerHTML = `<div class="error">解析失败: ${e.message}</div>`;
                    }
                } else {
                    const msg = slotsRes.status === 504 ? BLOCKED_HINT : `获取失败 (${slotsRes.status})`;
                    document.getElementById('slots').innerHTML = `<div class="error">${msg}</div>`;
                }
            }

            document.getElementById('lastUpdate').textContent = `上次更新: ${new Date().toLocaleTimeString('zh-CN')}`;
            document.querySelectorAll('.slot-generated, .slot-thinking').forEach(el => { el.scrollTop = el.scrollHeight; });
            requestAnimationFrame(() => window.scrollTo(0, scrollY));
            firstLoad = false;
            schedulePoll();
        }

        function schedulePoll() {
            if (pollTimer) clearTimeout(pollTimer);
            if (document.hidden) return;
            pollTimer = setTimeout(fetchAll, hasProcessing ? POLL_FAST : POLL_IDLE);
        }

        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                if (pollTimer) { clearTimeout(pollTimer); pollTimer = null; }
            } else {
                fetchAll();
            }
        });

        // 每 30s 刷新一次模型列表（发现新模型或模型停止）
        setInterval(() => { loadModels(); }, 30000);

        fetchAll();
    </script>
</body>
</html>
